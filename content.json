{"meta":{"title":"依旋的个人博客","subtitle":null,"description":"Welcome to my blog！","author":"echo","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"代码块及思路整理","date":"2017-02-28T12:26:24.665Z","updated":"2017-02-24T03:24:50.555Z","comments":true,"path":"2017/02/28/代码块及思路整理/","link":"","permalink":"http://yoursite.com/2017/02/28/代码块及思路整理/","excerpt":"","text":"给a标签设置一个onclick=”return false;” 阻止其跳转 12345678910111213141516171819202122&lt;!--给a标签设置一个onclick=\"return false;\" 阻止其跳转--&gt;&lt;body&gt; &lt;a href=\"http://baidu.com\"&gt;百度&lt;/a&gt; &lt;!--给浏览器返回一个false就可以阻止跳转了--&gt; &lt;a href=\"http://baidu.com\" onclick=\"return false;\"&gt;通过JS阻止默认行为&lt;/a&gt; &lt;!--此时不跳转--&gt; &lt;a href=\"http://baidu.com\" onclick=\"return testAge(17);\"&gt;未满十八岁请走开&lt;/a&gt; &lt;!--此时不跳转--&gt; &lt;a href=\"http://baidu.com\" onclick=\"return testAge(18);\"&gt;满十八岁请进开&lt;/a&gt; &lt;!--此时跳转--&gt;&lt;script&gt; function testAge(age) &#123; if (age &gt;= 18) &#123; alert(\"欢迎\"); &#125; else &#123; alert(\"走开\"); return false; &#125; &#125; //必须是返回false 浏览器才认识 其他的 0、\"\"、null、undefined都不行&lt;/script&gt;&lt;/body&gt; 京东搜索框，没有输入任何东西时，失去焦点自动设置输入框中的值为默认；若输入框中的值是默认的，则获取焦点清空输入框。 123456789101112131415161718192021222324252627282930&lt;body&gt;&lt;input type=\"text\" id=\"txt\" value=\"金融\" class=\"cls\"/&gt;&lt;script&gt; var txt = document.getElementById(\"txt\"); //如果输入框里是金融，且类名为cls，此时获取焦点时要清空 txt.onfocus = function () &#123; if(this.value === \"金融\" &amp;&amp; this.className === \"cls\") &#123; this.value = \"\"; &#125; &#125;; //如果输入框中没有任何内容，失去焦点时，要在输入框中显示金融 //设置类名为cls，为获取焦点时清空输入框做准备 txt.onblur = function () &#123; if(this.value === \"\") &#123; this.value = \"金融\"; this.className = \"cls\"; &#125; &#125;; //按键抬起时，如果输入框中的内容不为空，则将它的类名清空 //即获取焦点时输入框中的内容不再清空 txt.onkeyup = function () &#123; if(this.value !== \"\") &#123; this.className = \"\"; &#125; &#125;;&lt;/script&gt;&lt;/body&gt; 排他思想 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt;&lt;div class=\"box\" id=\"box\"&gt; &lt;div class=\"hd\"&gt; &lt;span class=\"current\"&gt;体育&lt;/span&gt; &lt;span&gt;娱乐&lt;/span&gt; &lt;span&gt;新闻&lt;/span&gt; &lt;span&gt;综合&lt;/span&gt; &lt;/div&gt; &lt;div class=\"bd\"&gt; &lt;ul&gt; &lt;li class=\"current\"&gt;我是体育模块&lt;/li&gt; &lt;li&gt;我是娱乐模块&lt;/li&gt; &lt;li&gt;我是新闻模块&lt;/li&gt; &lt;li&gt;我是综合模块&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var box = document.getElementById(\"box\"); var spans = box.getElementsByTagName(\"span\"); var lis = box.getElementsByTagName(\"li\"); // 点击 上面的标签 要排他 for (var i = 0; i &lt; spans.length; i++) &#123; spans[i].index = i;//自定义属性 spans[i].onclick = function () &#123; //干掉所有人 for (var j = 0; j &lt; spans.length; j++) &#123; spans[j].className = \"\"; &#125; //留下我自己 this.className = \"current\"; var index = this.index; //干掉所有人 for (var k = 0; k &lt; lis.length; k++) &#123; lis[k].className = \"\"; &#125; //留下对应的 lis[index].className = \"current\"; &#125;; &#125;&lt;/script&gt;&lt;/body&gt; 自定义属性优化12345678910111213141516171819&lt;script&gt; var box = document.getElementById(\"box\"); var spans = box.getElementsByTagName(\"span\"); var lis = box.getElementsByTagName(\"li\"); for (var i = 0; i &lt; spans.length; i++) &#123; spans[i].setAttribute(\"index\", i); spans[i].onclick = function () &#123; for (var j = 0; j &lt; spans.length; j++) &#123; spans[j].removeAttribute(\"class\"); &#125; this.setAttribute(\"class\", \"current\"); var index = this.getAttribute(\"index\"); for (var k = 0; k &lt; lis.length; k++) &#123; lis[k].removeAttribute(\"class\"); &#125; lis[index].setAttribute(\"class\", \"current\"); &#125;; &#125;&lt;/script&gt;","categories":[],"tags":[]},{"title":"前端学习中的零碎知识点","slug":"零碎知识点","date":"2015-05-05T04:30:21.000Z","updated":"2017-02-28T13:04:41.415Z","comments":true,"path":"2015/05/05/零碎知识点/","link":"","permalink":"http://yoursite.com/2015/05/05/零碎知识点/","excerpt":"","text":"在首页中引用样式表12&lt;link rel=\"stylesheet\" href=\"css/base.css\"/&gt;&lt;link rel=\"stylesheet\" href=\"css/index.css\"/&gt; 注意引用的顺序，base是公共样式，index是特定样式，特定网页的样式应该放在公共样式后面，以便对其进行覆盖常见布局 布局方式 固定布局 Fixed Layout 响应式布局 Responsive Layout 流式布局 Fluid Layout 栅格布局 Grid Layout 瀑布流布局 Waterfall Layout 圣杯布局 Holy Grail Layout:也称为双飞翼布局，特点是中间变化两边固定 清除浮动 什么是清除浮动 清除浮动，其实是清除当前元素周围的浮动元素，但是当前元素又不能影响别人，打不赢就跑，所以自己去下面独占一行了。 不浮动 float: none; clear: left/right/both; //清除左/右/全部 浮动 为什么要清除浮动 在布局的时候我们经常希望某些内容能够水平排布，水平排布后，由于内部内容不确定，高度不能简单的给一个定值。而如果不给高度，子元素又都浮动了，父盒子就会因为没有子盒子的支撑而塌陷。 利用清除浮动的这个特性，我们可以给父元素中最后一个不浮动的盒子使用 clear:both; 从而把父盒子的高度撑起来，并且能够根据内部内容的变化而改变高度。 清除浮动的方式 额外标签法 原理：单独使用一个标签加上clear:both跑到浮动元素下面，从而消除子盒子浮动造成的父盒子塌陷。 优点：通俗易懂，容易掌握 缺点：添加很多无意义的空标签，不符合结构与表现分离的原则，不利于后期维护 父元素设置 overflow：hidden 原理：让父盒子形成BFC，BFC的特性之一就是可以承载浮动元素 优点：不存在结构和语义化问题，代码量极少缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素 单伪元素 1234567891011.clearfix:after &#123; content: \"\"; height: 0; visibility: hidden; overflow: hidden; dispaly: block; /*不是inline就行*/ clear: both;&#125;.clearfix &#123; *zoom: 1; /*IE67*/&#125; 双伪元素 12345678910.clearfix:before, .clearfix:after &#123; content: \"\"; display: table;/*不是inline就行*/&#125;/*在有该类的元素内部元素的前面和后面添加元素*/.clearfix:after &#123; clear: both;&#125;/*只要after两侧有浮动元素，after就会跑到最下面，从而撑开带有该类名的父盒子*/.clearfix &#123; *zoom: 1;&#125; /*用于兼容IE/7/6*/ 注：用display:table是因为display:block伪元素仍然有宽度加了一个before是为了防止外边距合并通常说的清除浮动，指的是闭合浮动，即：清除子元素的浮动对父元素造成的影响。 BFC block formatting content 块格式化上下文，是w3c规定的一种独立渲染区域 特性为 BFC 会阻止外边距折叠 BFC 可以承载浮动的元素 BFC 可以阻止元素被浮动元素覆盖 触发BFC的情况： float 除了none以外的值（left，right） overflow 除了visible 以外的值（hidden，auto，scroll） display (table-cell，table-caption，inline-block) position（absolute，fixed） 根元素 圆角 CSS3属性，用于向元素添加圆角边框12345border-top-left-radius:2px;border-top-right-radius:2px;border-bottom-right-radius:2px;border-bottom-left-radius:2px;border-radius:2px;/*为简写形式，等价于以上代码顺序从左上角开始顺时针设置*/ 例如，一个盒子的 width: 10px; 设置 border-top-left-radius:10px;结果是半径为10px的1/4圆，左上角是圆弧。如果设置 border-radius:5px; 结果是直径为10px的圆。 网页构建策略 两种网站构建策略：渐进增强 progressive enhancement：先针对低版本浏览器做基本功能，再针对高版本浏览器去美化和增强。此策略一般用于PC端（PC端仍然有很多老版本浏览器）;优雅降级 graceful degradation：先针对高版本浏览器做最完整的功能，再针对低版本的浏览器进行修补，此策略一般用于移动端（移动端浏览器普遍比较新）;","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"jQuery学习笔记","slug":"jQuery基础","date":"2015-04-10T13:42:10.000Z","updated":"2017-02-28T13:03:20.556Z","comments":true,"path":"2015/04/10/jQuery基础/","link":"","permalink":"http://yoursite.com/2015/04/10/jQuery基础/","excerpt":"","text":"为什么学jQuery jQuery是什么 jQuery是JS的一个库，封装了开发过程中常用的功能，能够提高开发效率。 JS库就是把常用的代码放到一个单独的文件中，用的时候直接引用到页面里面就可以了。 使用jQuery 使用步骤：1.引包；2.写入口函数；3.实现功能（事件处理）； 入口函数就是指程序运行的时候最开始调用的函数，也就是程序开始的地方。 使用jQuery 版本介绍 最常用的两个版本： 1.12.x和最新推出的3.0.03.0版本不支持IE6/7/8 PC端的开发主要使用1.12.x版本 未压缩版（开发版）：代码可读性高，推荐在开发和学习环境中使用，方便查看源代码； 压缩版：去除了注释、换行、空格，并且将一些变量替换成了a,b,c之类的简单字符，基本没有可读性。推荐在生产和测试环境中使用，因为文件较小，减少网络压力。 引包注意 在使用jQuery之前，先把jQuery文件引到页面中来，如果在使用jQuery之前，没有引用jQuery文件，会报错； src路径一定要写正确 如果src路径写错，也会报错 入口函数 jQuery入口函数第一种：`$(document).ready(function() {函数主体});` 第二种：`$(function(){函数主体});` 以上两种写法，作用完全相同，用哪个都可以。 JS的入口函数`window.onload = function(){函数主体};` jQuery入口函数和JS入口函数的区别 书写个数不同 JS入口函数只能出现一次，出现多次会存在事件覆盖的问题。 jQuery的入口函数，可以出现任意多次，不会覆盖。 执行时机不同 JS入口函数是在所有资源加载完成后，才执行。（包括：页面、外部js文件、外部css文件、图片等） jQuery入口函数，是在文档加载完成后就执行。文档加载完成指的是：DOM树加载完成后，就可以操作DOM了，不用等到所有的外部资源都加载完成。 $符号 $ 就是一个普通的字符，可以用于变量名或函数名 JS命名规范允许出现的字符有：数字、字母、下划线、$。 123456var $ = \"字符串\";var $ = 123;function $()&#123; alert(\"我是函数'$'\");&#125;$(); // 调用上面我们自定义的函数$ **jQuery中的$实际是一个函数** 12345// jQuery中使用$的主要场景$(document）.ready(function()&#123;&#125;); // 调用入口函数$(function()&#123;&#125;); // 调用入口函数$(\"#btnShow\") // 获取id属性为btnShow的元素$(\"div\") // 获取所有的div元素 注意： jQuery里面的$函数，根据传入参数的不同，进行不同的调用，实现不同的功能。返回的是jQuery对象 jQuery这个JS库，为了避免冲突，给这个最重要的$函数还起了另外一个名字：jQuery jQuery函数跟$函数的关系：jQuery === $; jQuery对象 jQuery对象与DOM对象 DOM对象此处指的是：使用JS操作DOM的方法返回的对象 var btn = document.getElementById(“btnShow”); //普通的DOM对象 jQuery对象此处指的是：使用jQuery操作DOM的方法返回的对象 var $btn = $(“#btnShow”); // Query的DOM对象 jQuery拿到普通的DOM对象后会对其进行包装，让其成为具有jQuery方法的jQuery对象 jQuery对象转DOM对象 第一种方式 var btn1 = $btn[0]; //通过索引的方式把DOM对象取出来（推荐使用此方式） 第二种方式 var btn2 = $btn.get(0);//调用get()方法也可以 这两种方式使用哪一种都可以 DOM对象转jQuery对象 $(普通的DOM对象) //直接加一个$符号 jQuery选择器 JS中选择DOM元素的方法 考虑兼容性的话，JS提供的选择DOM的方法只有两个： document.getElementById();//通过id属性获取指定元素,返回唯一的DOM对象 document.getElementsByTagName();//通过标签名获取指定元素,返回DOM对象数组（即使只有一个元素）. jQuery选择器 基本选择器| 符号（名称） | 说明 | 用法 || :————: | :————: | :————: || # | Id选择器 | $(“#btnShow”).css(“color”, “red”);选择id为btnShow的一个元素（返回值为jQuery对象，下同） || . | 类名选择器 | $(“.liItem”).css(“color”, “red”);选择含有类liItem的所有元素 || 标签名 | 标签选择器 | $(“li”).css(“color”, “red”);选择标签名为li的所有元素 || ,隔开 | 并集选择器 | $(“div,p,li”).css(“color”, “red”);div、p、li都会被选中 || 紧挨着 | 交集选择器 | $(“li.current”).css(“color”, “red”);选择标签名为li并且类名为current的元素 | | 层级选择器| 符号（名称） | 说明 | 用法 || :————: | :————: | :————: || 空格 | 后代选择器 | $(“#j_wrap li”).css(“color”, “red”);选择id为j_wrap的元素的所有后代元素li || &gt; | 子代选择器 | $(“#j_wrap &gt; ul &gt; li”).css(“color”, “red”);选择id为j_wrap的元素的所有子元素ul的所有子元素li | 常用的过滤选择器| 符号（名称） | 说明 | 用法 || :————: | :————: | :————: || :eq(index) | 选择匹配元素中索引号为index的一个元素，index从0开始 | $(“li:eq(2)”).css(“color”, ”red”);选择li元素中索引号为2的一个元素 || :odd | 选择匹配元素中索引号为奇数的所有元素，index从0开始 | $(“li:odd”).css(“color”, “red”);选择li元素中索引号为奇数的所有元素 || :even | 选择匹配元素中索引号为偶数的所有元素，index从0开始 | $(“li:odd”).css(“color”, “red”);选择li元素中索引号为偶数的所有元素 | 筛选选择器（都是方法）| 符号（名称） | 说明 | 用法 || :————: | :————: | :————: || find(selector) | 查找指定元素的所有后代元素（子子孙孙） | $(“#j_wrap”).find(“li”).css(“color”, “red”);选择id为j_wrap的所有后代元素 || children(selector) | 查找指定元素的直接子元素（亲儿子元素） | $(“#j_wrap”).children(“ul”).css(“color”, “red”);选择id为j_wrap的所有子代元素ul || siblings(selector) | 查找所有其他的兄弟元素（不包括自己） | $(“#j_liItem”).siblings().css(“color”, “red”);选择id为j_liItem的所有兄弟元素 || next(selector) | 查找下一个兄弟元素 | $(“#j_liItem”).next().css(“color”, “red”);选择id为j_liItem的下一个兄弟元素 || parent(selector) | 查找父元素（亲的） | $(“#j_liItem”).parent(“ul”).css(“color”, “red”);选择id为j_liItem的父元素 || eq(index) | 查找指定元素的第index个元素，index是索引号，从0开始 | $(“li”).eq(2).css(“color”, “red”);选择所有li元素中的第二个 | jQuery中的DOM操作 样式操作 获取样式 $(selector).css(&quot;font-size&quot;);//参数表示要获取的样式 属性名称，返回”font-size”样式属性对应的值。 设置样式 设置单个样式： $(selector).css(&quot;color&quot;,&quot;red&quot;);//属性为：参数名，参数值 设置多个样式 $(selector).css({&quot;color&quot;:&quot;red&quot;,&quot;font-size&quot;:&quot;30px&quot;});//参数为对象 类名操作 为指定元素添加类名 addClass(className);$(selector).addClass(&quot;liItem&quot;);//不需要加点，只传名字 为指定元素移除类名 removeClass(className)$(selector).removeClass(“liItem”);//移除指定类名$(selector).removeClass(); //不指定参数，表示移除所有类名 判断是否包含某个类名 hasClass(calssName)$(selector).hasClass(“liItem”);//返回true或false 切换类名 toggleClass(className)$(selector).toggleClass(“liItem”);//切换类名，如果没有指定类名就添加，有就移除。 动画函数 显示隐藏动画show()方法 形式一： // 不带参数，没有动画 $(selector).show();//作用等同于css(“display”, ”block”) 形式二： //参数为数值，表示：执行动画时长 $(selector).show(2000);//单位为毫秒（ms），2000毫秒即2秒 形式三： //参数为字符串，是jQuery预设的值，共有三个，分别是：slow、normal、fast $(selector).show(“slow”); //slow：600ms、normal：400ms、fast：200ms 形式四： // 参数一可以是数值类型或者字符串类型 // 参数二表示：动画执行完后立即执行的回调函数 $(selector).show(2000, function() {}); hide()方法 1234 $(selector).hide(); $(selector).hide(1000); $(selector).hide(“slow”); $(selector).hide(1000, function()&#123;&#125;); 显示隐藏切换 $(selector).toggle(speed,callback); jQuery预设的三组动画效果的语法几乎一致： 参数可以有两个，第一个是动画的执行时长(可以是指定字符或毫秒)，第二个是动画执行完成后的回调函数。 - 滑入滑出动画 滑入效果 作用：让元素以下拉动画效果**展示**出来 `$(selector).slideDown(speed,callback);` 滑出效果 作用：让元素以上拉动画效果**隐藏**起来 `$(selector).slideUp(speed,callback);` **滑入滑出切换** `$(selector).slideToggle(speed,callback);` - 淡入淡出动画 **淡入效果** 作用：让元素以淡淡的进入视线的方式**展示**出来 `$(selector).fadeIn(speed, callback);` **淡出效果** 作用：让元素以渐渐消失的方式**隐藏**起来 `$(selector).fadeOut(1000);` **淡入淡出切换** 作用：通过改变不透明度，切换匹配元素的显示或隐藏状态 `$(selector).fadeToggle(&apos;fast&apos;,function(){});` **淡淡达到效果** 改变不透明度到某个值 `$(selector).fadeTo(0, .5)；` 作用：调节匹配元素的不透明度 与淡入淡出的区别：淡入淡出只能控制元素的不透明度从 完全不透明 到完全透明；而fadeTo可以指定元素不透明度的具体值。并且时间参数是必需的！ // 用法有别于其他动画效果 // 第一个参数表示：时长 // 第二个参数表示：不透明度值，取值范围：0-1 $(selector).fadeTo(1000, .5); //0全透，1全不透 // 第一个参数为0，此时作用相当于：.css(“opacity”, .5); $(selector).fadeTo(0, .5); - 动画方法总结 ![mark](http://olvlhfr9r.bkt.clouddn.com/blog/20170228/210311396.jpg)","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"几个小专题","slug":"专题","date":"2015-04-02T10:12:25.000Z","updated":"2017-02-28T13:00:19.729Z","comments":true,"path":"2015/04/02/专题/","link":"","permalink":"http://yoursite.com/2015/04/02/专题/","excerpt":"","text":"阻止a标签跳转1234567&lt;a href=\"#\"&gt;a&lt;/a&gt;&lt;!--点击后会跳到当前页面的头部--&gt;&lt;a href=\"#id\"&gt;a&lt;/a&gt;&lt;!--会跳转到指定标签的位置--&gt;&lt;a href=\"###\"&gt;a&lt;/a&gt;&lt;!--在数据库中有的时候会被当作注释--&gt;&lt;a href=\"javascript:\"&gt;a&lt;/a&gt;&lt;a href=\"javascript:;\"&gt;a&lt;/a&gt;&lt;a href=\"javascript:void(0)\"&gt;a&lt;/a&gt;&lt;a href=\"javascript:void(0);\"&gt;a&lt;/a&gt; 半透明123background-color: rgba(255, 0, 0, 0.5);/*透明度不继承*//*0-1 0全透明 1不透明*//*IE8不支持*/opacity: 0.5;/*透明度会继承*//*0-1 0全透明 1不透明*//*IE8不支持*/filter: alpha(opacity=20);/*0-100 0全透明 100不透明*//*只有IE678支持*/ 显示隐藏盒子1234567891011121314151617//rgba//opacity//filter//display//visibility//overflow也行//h0//w0//w0h0//定位 left//定位 top//m-很大//m 很大//定位 把他盖住//浮动 把他盖住//改变背景色 和后面的背景色一样//从结构上把他干掉","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"CSS3学习笔记","slug":"CSS3","date":"2015-03-26T12:18:43.000Z","updated":"2017-02-28T12:55:14.334Z","comments":true,"path":"2015/03/26/CSS3/","link":"","permalink":"http://yoursite.com/2015/03/26/CSS3/","excerpt":"","text":"CSS学习笔记 属性选择器 1234567 E[att]:包含attr属性，判断是否拥有某个属性 E[att=&quot;val&quot;]:属性值为val。属性是否等于val，属性的值 可以写单引号、双引号，也可以省略 E[att~=&quot;val&quot;]:属性值使用空格进行分割,有一个为val E[att^=&quot;val&quot;]:属性值以val开头 E[att$=&quot;val&quot;]:属性值以val结尾 E[att*=&quot;val&quot;]:属性中包含val的属性，可以是单个，也可以是多个。 E[att|=&quot;val&quot;]:属性以‘-’分割，其中有val值（如果属性只有val 那么也会被选中哦） 兄弟选择器 作用：选择相邻的兄弟节点 语法：选择器1~选择器2 指的是，在相同父元素中，选择器1之后的，所有满足选择器2 的元素。 伪类选择器 语法： 一个冒号（：） 注意： 1.标签E,必须是某个元素的子元素(在界面上) 2.如果通过`伪类选择器`找到的元素不是`E`则选择无效 12345678910111213141516171819202122 结构伪类 1.下面的这几个方法，如果有其他的兄弟元素，会一并考虑进去 E:first-child：第一个子元素 E:last-child：最后一个子元素 E:nth-child(4): nth-child 如果给的是 索引 是从1开始。nth-child使用的时候，如果前面有其他的元素，也会计算进去索引 E:nth-child(n)： 第n个子元素，计算方法是E元素的全部兄弟元素； E:nth-last-child(n)： 跟E:nth-child(n)类似 ，只是倒着计算； 其中n的取值范围是：0，1,2,3,4...线性累加 可以传入表达式，比如2n,2n+1等等 可以传入特殊字符：even(偶数) odd(奇数) 2.不考虑兄弟元素的 伪类选择器 E:first-of-type：第一个子元素 E:last-of-type:最后一个子元素 E:nth-of-type(4):索引从1开始，指的是第4个元素，不考虑兄弟元素。 E:nth-of-type(n+4):n从0开始。指的是索引第4个以后得所有元素。 3.empty选择器 E:empty 指的是E标签，并且内容为空（空格、换行也不能有）。 4.not选择器 E:not(选择器)：指的是，不满足括号内选择器条件的元素E。括号的内部，写的还是选择器。可以写属性选择器,伪类选择器等等。 例如：li:not([name])：li标签,没有name属性的全部获取. 目标伪类 E:target:选中当前锚点 伪元素选择器 作用： 在不改变页面html结构的基础上,为其添加标签 基本的语法为：两个冒号。也可以写一个冒号，但不建议。 例如， ::before表示在标签之前； ::after表示在标签之后； ::first-line表示第一行；可以自适应宽度。 ::first-letter表示第一个字母 ::selection表示选中的内容，* 只能设置的属性有`background-color`,`color`,`text-shadow` ::placeholder 设置`input`标签`placeholder`属性的显示颜色 注意：设置的是 input标签中的 placeholder属性的样式 完全按照标准 但是却无法生效 该样式 还处于测试阶段 需要添加一些 前缀 可以使用帮助文档 里面的提示 进行编写 如果 要兼容老实的浏览器 可以选用 js的方式去写 修改value值 以及 style属性 获取焦点事件 失去焦点事件 content 只要设置了 就能够看到内容不受限制，可以写空字符串 伪元素是行内元素，为了设置宽高，需要变为块级元素display:block;position:absolute; 伪元素其实相当于是子元素，即普通的行内元素，所以单标签不支持伪元素。 边框圆角 border-radius; 符合属性，特点： 1.给一个值，四边都有圆角； 2.给两个值，前面的设置的是左上和右下，后面设置的是右上和左下； 3.给三个值，第一个是左上，第二个是右上和左下，第三个是右下； 4.给四个值，顺序为左上、右上、右下、左下； 分开写： `border-top-left-radius;`//左上角 `border-top-right-radius;`//右上角 `border-bottom-right-radius;`//右下角 `border-bottom-left-radius;`//左下角 过渡属性 transition 适用于所有元素，包含伪元素before和after。设置的时候，要写上： *,::before,::after { transition: all 2s 3s; } transition-property: background-color,height,border;//过渡的属性，支持连写。基本上所有的属性 都支持 过渡。//如果我们想要为不同的过渡属性 指定不同的过渡时间,延迟时间，就只能使用这种分开的写法 transition-duration: 2s,5s;//过渡持续的时间,支持连写 transition-delay: 0s,2s;//延迟时间，支持连写 transition-timing-function: linear;//线型 设置速度 支持的速度设置选项 有几种 ease ease-in ease-out ease-in-out linear 实际开发中 我们不会用过渡 去做很长时间 效果 对于 时间很短的 过渡效果 直接不设置 使用默认的 ease 即可 用户 肉眼是看不出来的 复合写法如果是所有属性,都支持过渡,那么 直接写一个all即可.transition: all 2s 3s;//所有的属性 都支持过渡 时间为2s 延迟3s钟如果在默认的状态下添加，那么hover开始以及结束都会触发；如果在hover中添加，则只有hover的状态下应用该样式 ,鼠标离开之后，立刻还原； 设置颜色 rgb(0, 0, 0);//可以继承，不能设置透明度，取值为0-255 rgba(0, 0, 0, .5);//可以继承，前三个参数取值为0-255，最后一个参数表示透明度，取值0-1 hsl(296, 90%, 39%);//不可以继承，可以跟rgb互相转换，不能设置透明度 hsla(296, 90%, 39%, .5);//不可以继承，最后一个参数是设置透明度 文字阴影 text-shadow(); 文字阴影： 阴影的方向 x跟y 参数1: x的移动值 正方向是 右; 参数2: y的移动值 正方向是 下; 参数3: 设置影子的 放大; 参数4: 颜色; 注意: 阴影的颜色 不设置 默认黑色 影子的大小 默认是跟 文字一样大 如果只想设置文字的放大 必须要 将 x 跟y的移动值 进行设置 10px red 支持过渡 text-shadow: 1px 1px 1px red; 盒子阴影 box-shadow(); 盒子阴影 参数0: inset 向内阴影（可选） 参数1: x →向右是正向 参数2: y ↓向下是正向 参数3: 模糊的程度;(可选) 参数4: 直接放大影子 不会模糊(可选) 参数5: 颜色;(可选) 注意: 默认颜色为黑色; 支持写 多个影子 支持过渡 一般影子 就给一丢丢即可 并且是模糊的 box-shadow: 0 20px 20px gray; 渐变（颜色） 线性渐变 (就是朝着某个方向发生进行渐变)linear-gradient(); /*语法组合方式 可以添加多个颜色*/ background-image: linear-gradient(方向,开始颜色 开始位置 ,颜色2 开始位置,颜色3 开始位置.....); 参数1: 方向 1.可以直接写 to 方向 to 方向1（方向2 ....） 2.可以直接写角度：45deg... 参数2: 颜色1; 参数3: 颜色2; ...可以继续往后写颜色 background: linear-gradient(to top,skyblue,white);//自下而上,从skyblue渐渐变为white;background: linear-gradient(to top left,skyblue,white);//自右下到左上,颜色从skyblue渐渐变为white;background: linear-gradient(45deg,skyblue,hotpink);//方向朝着顺时针45度角,颜色从skublue渐变为hotpink;background: linear-gradient(45deg,skyblue,hotpink,purple,orange,yellow);//方向朝着顺时针45度角,颜色从skyblue到hotpink再到purple再到orange再到yellow;background-image: linear-gradient(45deg,red 10px,yellow 20px);//朝着 顺时针45度 红色到 10px结束 黄色从 20px开始;background-image: linear-gradient(45deg,red 10%,yellow 20%);//朝着 顺时针45度 红色到10%结束 黄色从 20%开始; 径向渐变 (以某个点作为圆心,向四周扩散的渐变)radius-gradient()； 设置的是一个 圆形(椭圆形)的 渐变 参数1: 半径;（只设置一个值，得到一个圆；设置两个值，得到椭圆） 参数2: 圆的位置;（at center) 参数3: 颜色1; 参数4: 颜色2; .... background-image: radial-gradient(500px 200px,red,yellow);//background-image: radial-gradient(500px 200px at center ,red,yellow);//background: radial-gradient(100px 200px,red 10%,green 10%);//横向半径100px 红色10% 绿色20%background: radial-gradient(100px 200px,red 10px,green 20px);//横向半径100px 红色10px 绿色 20px 注意： 渐变生成的是 图片 不能设置给 backgroundcolor,要设置给background-image; background-image: linear-gradient(to top left,skyblue,white); 渐变属性 不支持颜色过渡(*) 支持 background-position过渡 由于是CSS3的样式兼容性 较差 目前实际开发中 渐变使用较少 主流还是 使用图片 转换 transform如果 使用 多个transform属性编写 下面的会 覆盖上面 平移 translate(); 使用变换的时候 可以理解为 脱离标准流 浮动流... 不影响其他的元素 移动 x的正方向是 → y的正方向是 ↓ transform: translateX(100px);//分开设置 transform: translateY(100px); transform: translate(100px, 100px);//合写 transform: translateX(100px) translateY(100px);//合写 缩放 scale() 缩放支持两个轴向的缩放:x 跟 y scale(0, 0) 参数1: x; 参数2: y; 传递的值 不是一个 具体的像素 而是缩放的比例 即取值为0-1的小数 transform: scaleX(.5); transform: scaleY(.5); transform: scaleX(.5) scaleY(.5); transform: scale(.5, .5); 旋转 rotate() 默认的旋转中心为盒子的中心，使用transform-origin来设置旋转的中心。 transform-origin: top right; 旋转的单位，建议使用deg（度） transform: rotate(180deg); 扭曲 skew() 参数1: x; 参数2: y; 单位deg（度） 一般情况下，建议给一个参数。两个参数不好控制。 transform: skewX(30deg); transform: skewY(30deg); transform: skew(30deg, 30deg); 盒子模型 box-sizing 取值有两个： 1.border-box: 优先保证 自己所占区域的大小不变 设置 border和padding，不会改变自己整体的大小 只会把里面的内容缩小，来保证整个盒子的大小不变 2.content-box 优先保证里面内容区域(content)的大小不变 添加border,padding的时候 自己整个的会变大，即整个盒子会变大 默认的是 content-box","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"THML5基础知识","slug":"HTML5","date":"2015-03-17T14:03:23.000Z","updated":"2017-02-28T12:53:23.654Z","comments":true,"path":"2015/03/17/HTML5/","link":"","permalink":"http://yoursite.com/2015/03/17/HTML5/","excerpt":"","text":"THML5基础知识 HTML5和H5的区别 H5包含三个部分：HTML5； CSS3; JavaScript； DOCTYPE的作用 一个标准的HTML文档,开头第一句都应该是&lt;!DOCTYPE&gt;,根据不同的HTML版本,内容上会有差别.DOCTYPE并不是HTML标签,而是一个声明。 作用: 告诉浏览器编写页面所用的标记的版本. 通俗一点:高速浏览器按照什么来解析页面。 DOCTYPE写法_HTML4中 在HTML4.01中有三种DOCTYPE声明，分别是： 1.HTML 4.01 Strict Emmet语法为: html:4s+tab 1 &lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt; 2.HTML 4.01 Transitional Emmet语法为: html:4t tab 12 &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; 3.HTML 4.01 Frameset 没有找到对应的Emmet语法 12 &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; DOCTYPE写法_HTML5中 Emmet语法为:html:5或！tab Emmet语法创建文档结构 * `html:5`或`!`：HTML5文档类型 * `html:xt`：XHTML过渡型文档类型 * `html:xs`：XHTML严格型文档类型 * `html:4t`：HTML4过渡型文档类型 * `html:4s`：HTML4严格型文档类型 语义标签原来使用div+class的格式htlm5新语义标签： header、main、footer、nav、aside、article、section 有兼容性问题，解决办法： 方法1:js代码 在页面中添加创建header标签的代码 修改header的样式,添加display:block 123456789101112 &lt;style&gt; header&#123; height: 100px; background-color: orangered; /*在低版本的ie中,如果想要显示h5的新语义标签,需要设置为block*/ display: block; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; // 使用代码创建header标签 document.createElement(\"header\"); &lt;/script&gt; js框架 直接导入js框架,js框架内部干的事情类似于我们刚刚写的js代码,但是处理的逻辑会多一些。 123 &lt;!--使用js框架来解决html5新语义标签的方法--&gt; &lt;script src=\"js/html5shiv.min.js\"&gt; &lt;/script&gt; 优化代码执行–hack写法无论是js,或者js框架都需要执行js代码才能够解决兼容性问题,但是在高版本的浏览器中,那段js代码就没有必要执行了,所以我们通过一个叫做[hack]的方式来减少性能的浪费用法：使用 hack语法 将需要执行的js的代码包裹起来 123456 //lte： less than equel &lt;!--[if lte IE 8]&gt; &lt;script&gt; alert(\"这段js代码执行了\"); &lt;/script&gt; &lt;![endif]--&gt; 1234567 &lt;!--在低版本的 ie中 完成 创建 标签的 功能 并且会自动添加上 display block 有多个的话 也会 自动帮助我们生成 --&gt; &lt;!--使用条件注释 让 下列js文件 只在 低版本的 ie中 导入--&gt; &lt;!--[if lte IE 8]&gt; &lt;script src=\"js/html5shiv.min.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;![endif]--&gt; 新type属性 color //页面上显示一个颜色选择框 date //页面上显示一个可以选择日期的框 number //只能输入数字 email //键盘会带有\\@符号 search//键盘会有搜索按钮 tel //键盘会只显示数字 range //页面上显示一个可拖动的滚动条，可以用来显示进度 month //显示年和月 week //显示年和周 新表单属性 placeholder //输入框中默认显示的文字 autofocus //自动获取焦点 multiple //上传文件可以多选 autocomplete //自动完成 必须满足两个条件：首先 input 必须有 name属性 form表单 必须 提交过，点击submit按钮 pattern //设置正则表达式，规范输入的内容 required //非空验证 oninvalid事件，验证失败以后触发 oninput事件，input内容改变时触发 setCustomValidity()设置默认提示信息 获取dom元素 querySelector()方法 只能找到 匹配的第一个 从上往下找； querySelectorAll(‘li’);返回的是 数组，哪怕只有一个元素 也是 数组； 新表单元素 datalist；该元素规定了输入区域的选项列表,可以让用户有一些选项。 1234567891011 &lt;!--可以指定一些选项 input 通过list属性关联 datalist 需要设置id属性 --&gt; &lt;form action=\"\"&gt; &lt;input type=\"tel\" list=\"telList\" placeholder=\"请输入电话号码\"/&gt; &lt;datalist id='telList'&gt; &lt;option value=\"1888888\"&gt;&lt;/option&gt; &lt;option value=\"1999999\"&gt;&lt;/option&gt; &lt;/datalist&gt; &lt;/form&gt; 多媒体标签 视频标签：video src 指定播放的视频 autoplay 自动播放 controls 控制器 width、height 宽高设置的是 video标签的 大小，内部的视频还是优先考虑自己的缩放，保证观影效果。 loop 循环 缺点：视频可以直接另存为 移动端 使用video标签居多 桌面端 使用flash居多 音频标签：audio src:音频的地址 controls:音频播放控制器 autoplay:自动播放 loop:循环 12 &lt;audio src=\"song.ogg\" controls=\"controls\" autoplay loop&gt; &lt;/audio&gt; 兼容问题 通过source属性，可以指定多种格式的视频或音频 浏览器会从上往下解析，能够播放即开始播放，后面的视频或音频就不考虑了； 123456 &lt;video controls autoplay loop width='200px' height='300px'&gt; &lt;source src=\"movie/movie04.ogg\"&gt;&lt;/source&gt; &lt;source src=\"movie/movie.mp4\"&gt;&lt;/source&gt; 亲爱的用户,你的浏览器版本太低了,请立刻升级,建议下载谷歌浏览器 &lt;a href=\"#\"&gt;点我,点我.点我&lt;/a&gt; &lt;/video&gt; class操作 classList；通过dom元素获取，返回的是一个对象，里面有多种操作class的方法： add 增加class remove 移除class。若要移除多个，分别用引号引起来，中间用逗号隔开。 contains 判断是否存在 toggle 切换 自定义属性HTML5中 推出了一个 推荐的 数据格式data-* data-xxx-xxx-xxx 只要我们需要 可以一直往后写 实际生成的时候，会去掉 第一个data- 后面的中间的 - 去掉，字母变为大写。比如： data-meat-one ---&gt; meatOne 属性可以使用大写，但是最终生成的对象，会使用小写字母 所有通过 data-添加的属性 都保存在 dataset这个属性中 可以通过.语法获取，也可以通过[]来获取 进度条progress标签和meter标签&lt;progress value=&#39;.5&#39;&gt;&lt;/progress&gt;&lt;meter&gt;&lt;/meter&gt;可以使用自定义的方式 保证 页面的显示效果","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"BOM","slug":"BOM","date":"2015-03-09T11:10:35.000Z","updated":"2017-02-28T12:51:08.820Z","comments":true,"path":"2015/03/09/BOM/","link":"","permalink":"http://yoursite.com/2015/03/09/BOM/","excerpt":"","text":"BOM浏览器对象模型 window对象 window对象是JavaScript中的顶级对象 所有定义在全局作用域中的变量、函数都会变成window对象的属性和方法 window对象下的属性和方法调用的时候可以省略window onload();//窗体加载完成事件（窗体加载完成才执行） window.open(url,target,param); url 要打开的地址； target新窗口的位置；_blank _self _parent(父框架) param 新窗口的一些设置； 返回值，新窗口的句柄,返回一个窗体对象，可供close()调用； window.close(); 关闭窗口,谁调用就关闭谁 定时器 定时执行 var timerId = setInterval(function(){},delay); clearInterval(timerId);//间隔时间执行，不是特别精确 延迟执行 var timerId = setTimeout(function(){},delay); //设置定时器 setTimeout 参数 1回调函数 2延迟时间（单位是毫秒） 返回值 数字，即定时器的编号 clearTimeout(timerId);//清除定时器 参数是数字，即要清除的定时器 location对象 window.location– location相当于浏览器地址栏– 可以将url解析成独立的片段 location对象的属性– href– location.reload(); //重新加载 screen对象navigator对象history对象 历史记录管理 后退 history.back(); history.go(-1) 前进 history.forward(); history.go(1); Date对象 var date = new Date(); //创建日期对象 date.valueOf(); //从1970-1-1 00:00:00:000 到现在的毫秒数 var date2 = Date.now(); //直接返回的就是当前时间的毫秒值,IE9+才支持 var date3 = +new Date(); // 不支持now的方法 日期格式化： var date = new Date(); console.log(date.toDateString());//Sun Nov 06 2016 console.log(date.toTimeString());//20:19:19 GMT+0800 (中国标准时间) console.log(date.toLocaleDateString());//2016/11/6 console.log(date.toLocaleTimeString());//下午8:19:19 12345678date.getYear();//返回年date.getMouth();//返回月份，0-11date.getDate();//返回当天是当月的第几天date.getDay();//返回星期几， 0-6date.getHours();//返回当前时间的小时date.getMinutes();//返回当前时间的分钟date.getSeconds();//返回当前时间的秒数date.getMilliseconds();//返回当前时间的毫秒数 日期转换： 基本包装类型 三个特殊的引用类型：String/Number/Boolean 例： var s1 = &quot;zhangsan&quot;; var s2 = s1.substring(5); s1是基本类型，基本类型是没有方法的 当调用s1.substring(5)的时候，先把s1包装成String类型的临时对象，再调用substring方法，最后销毁临时对象 相当于：123var s1 = new String(\"zhangsan\");var s2 = s1.substring(5);s1 = null; 注意：Number和Boolean基本不用，而且会引起歧义 创建基本包装类型的对象：1234var num = 18; //数值，基本类型var num = Number(\"18\"); //类型转换，基本类型var num = new Number(18); //基本包装类型，对象//**new会改变this的指向，并返回** String类型 String类型是字符串的包装类型，提供给我们很多操作字符串的方法var strObj = new String(&quot;hello world&quot;); 对象有方法和属性 属性：length返回当前字符串总共多少字符 方法：注意：字符串中所有的方法都不会改变字符串本身，操作完成后会返回一个新的字符串。 字符方法 charAt(); //获取指定位置处字符 charCodeAt(); //获取指定位置处字符的ASCII码 str[0]; //ES5，IE8+支持 和charAt()等效 操作方法 concat(); //拼接字符串，和+一样 slice(); //从start位置开始，截取到end位置，end取不到 substring(); //从start位置开始，截取到end位置，end取不到 substr(); //从start位置开始，截取length个字符 位置方法 indexOf(); //返回指定内容在元字符串中的位置。如果没有，则返回-1； lastIndexOf(); //从后往前找，只找第一个匹配的。没有则返回-1； 其他方法 trim()； //只能去除字符串前后的空白 split()； //把字符串切割成字符数组，参数是什么，就以什么来分割； 大小写转换方法 to(Locale)UpperCase(); //转换大写 to(Locale)LowerCase(); //转换小写 匹配方法 search(); replace();//从左往右找，找到一个替换后就返回 localeCompare(); //两个字符串比较的是ASCII码 s1.localeCompare(s2); s1 &gt; s2 返回正数，一般是1 s1 == s2 返回0 s1 &lt; s2 返回负数，一般是-1 fromCharCode() String.fromCharCode(101,102,103); //把ASCII码转换成字符串.","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"js高级","slug":"js高级","date":"2015-02-27T12:50:55.000Z","updated":"2017-02-28T12:49:40.092Z","comments":true,"path":"2015/02/27/js高级/","link":"","permalink":"http://yoursite.com/2015/02/27/js高级/","excerpt":"","text":"offset系列 offsetWidth和offsetHeight 用来得到对象的大小 offsetHeight和style.height的区别 demo.style.height只能获取 行内样式 ，如果样式写到了其他地方，甚至根本就没写，便无法获取 style.height是 字符串（而且带单位） ，offsetHeight是 数值 demo.style.height可以 设置 行内样式，offsetHeight是只读属性 因此，一般用demo.offsetHeight来获取某元素的真实宽度/高度，用style.height来设置宽度/高度 offsetHeight的构成 offsetHeight = height+padding+border； offsetWidth = width+padding+border; 即：包括 自身高度 内边距 边框，不包括 外边距 offsetParent 返回该对象距离最近的 带有定位 的父级 如果当前元素的所有父级元素都没有定位（position为absolute或relative），offsetParent为body 如果当前元素的父级元素中有定位（position为absolute或relative），offsetParent取最近的那个父级元素 另外注意offsetParent与parentNode的区别parentNode只找自己的上一级（亲爹） offsetLeft 和 offsetTop 用来得到对象的位置（注意：没有offsetRight和offsetBottom） offsetLeft的构成 到距离自身最近的（带有定位的）父元素的 左侧 的距离； 如果所有父级都没有定位则以body 为准； offsetLeft 是 自身 border 左侧到 父级 padding 左侧（即 父级 border 右侧）的距离； offsetLeft和 style.left 的区别 style.left只能获取行内样式 offsetLeft 只读 ，style.left可读可写 offsetLeft是 数值 ，style.left是 字符串 并且有单位px 如果没有加定位，style.left获取的数值可能是无效的 最大区别在于offsetLeft以border左上角为基准，style.left以margin左上角为基准 例如：left:20px; margin:20px; Math对象 Math对象常用方法 Math.ceil(x);//天花板函数，向上取整 Math.floor(x);//地板函数，向下取整 Math.round(x);//就近取整，会整体比较，以 .5 为界限，小于的舍，大于的入，等于的，正数入负数舍 Math.abs(x);//取绝对值例： Math.ceil(1.5);//2 Math.ceil(-1.5);//-1 Math.floor(1.5);//1 Math.floor(-1.5);//-2 Math.round(1.5);//2 Math.round(-1.5);//-1 Math.abs(-1.5);//1.5 动画原理 动画原理公式 动画原理公式： leader = leader + step; leader表示盒子当前位置 step表示步长 box.style.left = box.offsetLeft + 10 + &quot;px&quot;; 让setInterval不断执行某个函数修改盒子的位置属性最后就实现了动画的效果 动画函数封装 动画函数较为复杂，却又很常用对于这样的函数，我们一般都会进行封装 需求：能够让任意对象移动到指定位置。 动画函数改进 然而封装之后的函数还有很多问题，所以我们要对其进行进一步改进 判断运动方向 完善终点检测 终点清除定时器 手动设置对象位置到终点 调用开始先清理定时器，防止多次调用 12345678910111213141516//需求：让任意对象移动到指定位置 function animate(obj, target) &#123; clearInterval(obj.timer);//防止重复设定定时器 如果有就清掉 如果没有也无所谓 obj.timer = setInterval(function () &#123; var leader = obj.offsetLeft;//获取用offset var step = 10; step = leader &lt; target ? step : -step;//往左往右都行 if (Math.abs(leader - target) &gt;= Math.abs(step)) &#123;//距离大于步长就可以走 leader = leader + step; obj.style.left = leader + \"px\";//字符串而且有单位 &#125; else &#123; obj.style.left = target + \"px\";//手动放到目标上 clearInterval(obj.timer);//到达目标后清理定时器 &#125; &#125;, 15);//每秒 25帧就有动画效果了 60帧就比较细腻了 &#125; scroll系列 scrollHeight 和scrollWidth 对象内部实际内容的高度/宽度 scrollTop 和scrollLeft 被卷去部分的 顶部/左侧 到可视区域 顶部/左侧 的距离 页面滚动座标 获取页面滚动座标 页面滚动座标非常常用，但是有很大的兼容性问题，可以合写为： 123var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;//window.pageYOffset是主流的浏览器都支持的写法，后面的是专为类似IE6/7/8而准备的，如果获取不到，最后是0；var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0; 封装自己的scroll() 由于非常常用，每次都写上面那一大堆很麻烦。我们可以封装一个自己的scroll()方法，返回页面滚动座标。 123456function scroll() &#123; return &#123; top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0; left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0; &#125;&#125; 调用格式： scroll().top;//返回对象被卷去部分的 顶部 到可视区域 顶部 的距离 scroll().left//返回对象被卷去部分的 左侧 到可视区域 左侧 的距离 onscroll事件：每滚动一像素都会触发该事件 缓动动画 原理公式 动画公式leader = leader + step 匀速动画公式step = 定值 leader = leader + step 缓动动画公式step = ( target - leader ) / 10 leader = leader + step 缓动动画的好处 他的移动是有尽头的。不像基础匀速运动那样无限移动。 有非常逼真的缓动效果，实现的动画效果更细腻。 如果不清除定时器，物体永远跟着目标leader在移动。 缓动函数封装1234567891011121314//封装 动画函数 能让任意对象 移动到指定位置 function animate(obj, target) &#123; clearInterval(obj.timer);//清理定时器，避免重复调用定时器 obj.timer = setInterval(function () &#123; var leader = obj.offsetLeft; var step = (target - leader) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);//step要取整数，且数值上大于等于自己，所以正数向上取整，负数向下取整 leader = leader + step; obj.style.left = leader + \"px\"; if (leader === target) &#123; clearInterval(obj.timer); &#125;//当位置等于目标时，清除定时器 &#125;, 15); &#125; 封装缓动框架 封装 获取盒子计算后样式（即最终样式）的方法 123456789//封装 获取计算后样式属性的兼容函数 能够获取任意对象的任意属性 function getStyle(obj, attr) &#123; if (window.getComputedStyle) &#123;//主流的浏览器支持的方法，W3C规定的 return window.getComputedStyle(obj, null)[attr]; //第二个参数是伪元素，传入null即可 &#125; else &#123; return obj.currentStyle[attr];//非主流的IE6/7/8采用的方法 &#125; &#125; 访问属性的两种方式 div.style.width div.style[&quot;width&quot;] 封装123456789101112131415161718192021222324252627282930313233343536373839function animate(obj, json, fn) &#123;//json &#123;attr:target&#125; clearInterval(obj.timer); obj.timer = setInterval(function () &#123; //定时器肯定要清除 每一个属性都到达了才能清除 //假设这一次执行完成后 所有属性都到达了目标值 var flag = true; for (var k in json) &#123;//json 属性名:属性值 attr:target k:json[k] if (k === \"opacity\") &#123;//单独处理透明度 //var leader = parseInt(getStyle(obj, k)) || 0; var leader = getStyle(obj, k) * 100;//透明度没有单位的 也不用parseInt //没必要给默认值 也不应该给 var target = json[k] * 100; var step = (target - leader) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); leader = leader + step; obj.style[k] = leader / 100; //之前扩大100倍 现在缩小100倍数 透明度没有单位 &#125; else if (k === \"zIndex\") &#123;//层级也要特殊处理 obj.style.zIndex = json[k];//层级不需要渐变 直接设置成目标值 &#125; else &#123; var leader = parseInt(getStyle(obj, k)) || 0; var target = json[k]; var step = (target - leader) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); leader = leader + step; obj.style[k] = leader + \"px\"; &#125; if (leader !== target) &#123;//当前属性还没有到达目标 flag = false;//说明假设错了 &#125; &#125; if (flag) &#123;//最后仍然是true 说明都到了 clearInterval(obj.timer);//清理定时器 if (fn) &#123;//如果有才调用 fn();//动画执行完成后 会执行传入的回调函数 &#125; &#125; &#125;, 15); &#125; client系列 clientWidth和clientHeight 偏移offsetWidth: width + padding + border 卷曲scrollWidth: width + padding //不包含border 指的是内部内容的大小 可视clientWidth: width + padding //不包含border clientTop和clientLeft clientTop和clientLeft没什么用 他们就是borderTop和borderLeft（如果有滚动条会包含滚动条的宽度，但谁见过滚动条在顶部或者左侧的？！） 网页可视区宽和高 网页可视区宽高的兼容写法 页面可视区宽高非常常用，但是有很大的兼容性问题，可以合写为 1var clientWidth = window.innerWidth|| document.documentElement.clientWidth|| document.body.clientWidth|| 0; 封装自己的client() 1234567//封装一个 能够获取网页可视区宽高的兼容函数function client() &#123; return &#123; width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0, height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0 &#125;;&#125; 体会响应式布局的原理 当页面宽度 大于 960 像素的时候 页面为红色并显示computer 当页面宽度 大于 640 小于 960 页面为绿色并显示tablet 剩下的情况为黄色并显示mobile 123456789101112131415161718192021222324252627282930var timer = null;responsive();//onscroll onresize onmousemove事件 执行频率很快//如果要执行的是非常消耗资源的代码 并且没必要频率那么大 可以进行节流window.onresize = function () &#123; clearTimeout(timer); timer = setTimeout(responsive, 500);&#125;;function responsive() &#123; console.log(\"很消耗资源\"); if (client().width &gt; 960) &#123;//电脑 document.body.style.backgroundColor = \"red\"; document.body.innerHTML = \"computer\"; &#125; else if (client().width &gt; 640) &#123;//平板 document.body.style.backgroundColor = \"green\"; document.body.innerHTML = \"tablet\"; &#125; else &#123; document.body.style.backgroundColor = \"yellow\"; document.body.innerHTML = \"moblie\"; &#125;&#125;//封装一个 能够获取网页可视区宽高的兼容函数function client() &#123; return &#123; width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0, height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0 &#125;;&#125; 事件对象 事件 oncnlick、onmouseover、onmouseout、onfocus、onblur 事件对象简介 在触发事件时，会产生一个事件对象 event，这个对象中包含着与事件有关的信息。 所有浏览器都支持event对象，但支持的方式不同。比如鼠标操作时候，会添加鼠标位置的相关信息到事件对象中。 普通浏览器支持 传入参数 IE6、7、8 支持 window.event。 事件对象的兼容性写法var event = event || window.event; 三个重要坐标 clientX clientY 当前窗口的左上角为基准点 screenX screenY 当前屏幕的左上角为基准点 pageX pageY 以当前文档（即网页）的左上角为基准点 IE678不支持pageX和pageY 但是我们可以采取另一种方式 12var pageY = event.pageY || event.clientY + document.documentElement.scrollTop;var pageX = event.pageX || event.clientX + document.documentElement.scrollLeft; 事件目标 12//兼容IE浏览器的写法var targetId = event.target ? event.target.id : event.srcElement.id; 注册事件的三种方式 传统on方式（onclick） 对同一个事件目标设置两次以上的同样事件，后面的事件会覆盖前面的时间 addEventListener(主流浏览器都支持) 可以给同一个对象的同一个事件注册多个事件处理函数（监听者）,后面不会覆盖前面。 可以设定捕获或者冒泡。 attachEvent(IE6、7、8) 可以给同一个对象的同一个事件注册多个事件处理函数（监听者）,后面不会覆盖前面。 可以设定捕获或者冒泡。 1234567891011//封装 注册事件 的兼容函数//1.元素对象 2.事件的名称（传入没有on的字符串） 3.事件处理函数 function addEvent(element, eventName, listener) &#123; if(element.addEventListener) &#123; element.addEventListener(eventName, listener, false); &#125; else if(element.attachEvent) &#123; element.attachEvent(\"on\" + eventName, listener); &#125; else &#123; element[\"on\" + eventName] = listener; &#125; &#125; 123456789//调用封装的addEvent函数//例如：为btn添加点击事件btn.onclick = function() &#123; alert(\"呵呵哒\");&#125;;//调用函数来实现addEvent(btn, \"click\", function() &#123; alert(\"呵呵哒\");&#125;); 移除事件的三种方式 on方式 btn.onclick = null; removeEventListener 如果注册的时候使用的是匿名函数，则无法移除 detachEvent 如果注册的时候使用的是匿名函数，则无法移除 1234567891011//封装 移除事件的兼容方法//function removeEvent(element, eventName, listener) &#123; if(element.removeEventListener) &#123; element.removeEventListener(eventName, listener, false); &#125; else if(element.detachEvent) &#123; element.detachEvent(\"on\" + eventName, listener); &#125; else &#123; element[\"on\" + eventName] = null; &#125;&#125; 1234567//调用removeEvent函数//function fn () &#123; alert(\"呵呵哒\");&#125;//调用removeEvent(btn, \"click\", fn); 注意：通过innerHTML清空内容的时候和事件相关的函数不会被销毁，仍然遗留在内存中，因此建议使用removeChild来清除 事件捕获 btn.addEventListener(“click”,handle,true); 最后一个参数为true-事件捕获 事件冒泡 当一个元素上的事件被触发的时候，比如说鼠标点击了一个按钮，同样的事件将会在那个元素的所有祖先元素中被触发。这一过程被称为事件冒泡；这个事件从原始元素开始一直冒泡到DOM树的最上层。 btn.addEventListener(element,”click”,false); 最后一个参数为false-事件冒泡 大多数浏览器都支持-推荐使用的方式 123&lt;div id=\"father\"&gt; &lt;div id=\"son\"&gt;&lt;/div&gt;&lt;/div&gt; son--&gt;father--&gt;document.body--&gt;document.documentElement(html)--&gt;document--&gt;window 事件传播的三个阶段是： 捕获阶段 冒泡阶段 目标阶段事件捕获阶段：事件从最上一级标签开始往下查找，直到捕获到事件目标(target)。事件冒泡阶段：事件从事件目标(target)开始，往上冒泡直到页面的最上一级标签。 注意：不是所有的事件都能冒泡。以下事件不冒泡：blur、focus、load、unload。 阻止事件冒泡 123456//兼容IE浏览器的方法 if(event.stopPropagation)&#123; event.stopPropagation();&#125; else &#123; event.cancelBubble = true;&#125; 鼠标事件 mousedown mouseup mousemove mouseover mouseout click dblclick 键盘事件 onkeydown onkeypress onkeyup 事件对象的属性： onkeydown onkeyup 输出的是键盘码 onkeypress输出的是ASCII码表 键盘码中只有数字字母与ASCII码编号相同 正则表达式 声明和使用 通过构造函数定义 var 变量名= new RegExp(/表达式/); 通过直接量定义（简单方便，我们一般用这个） var 变量名= /表达式/; 常用方法，可用于检测传入的字符串是否符合该规则并返回布尔值 exp.test(“要检测的字符串”) 预定义类和转义符 预定义类 . [^\\n\\r] 除了换行和回车之外的任意字符 \\d [0-9] 数字字符digit \\D [^0-9] 非数字字符 \\w [a-zA-Z0-9] 单词字符(所有的英文字母数字和) word \\W [^a-zA-Z0-9_] 非单词字符 \\s [\\f\\r\\n\\t\\v] 不可见字符 space \\S [^\\f\\r\\n\\t\\v] 可见字符 转义符 \\f 表示换页 form feed \\t 表示水平制表符 table \\v 表示垂直制表符 vertical table| 表示或 或的优先级最低 可以通过()提升优先级 字符类简单类[abc] 表示该位置可以出现的字符 负向类[^abc] 表示该位置不可以出现的字符 范围类[a-e] 表示该位置可以出现的字符的范围 组合类[a-xA-E0-9] 范围类的组合 边界 量词 括号 边界^ 会匹配行或者字符串的起始位置 ^只有在[]内才表示非 在外边表示开始 \\$ 会匹配行或字符串的结尾位置 ^\\$在一起 表示必须是这个（精确匹配） 量词&quot;*&quot; 重复零次或更多 x&gt;=0 &quot;+&quot; 重复一次或更多次 x&gt;=1 &quot;?&quot; 重复零次或一次 x=(0||1) {n} n次 x=n {n,} 重复n次或更多 x&gt;=n {n,m} 重复出现的次数比n多但比m少 n&lt;=x&lt;=m 括号总结()表示一组 []表示一个字符的位置 {}表示次数 常见项目的匹配 常见项目的匹配网上有很多（例如搜索常用正则表达式大全），无需记忆，能看懂即可匹配国内电话号码： `&lt;pre style=&quot;background:#272822&quot;&gt;/^0\\d{2,3}-\\d{7,8}$/&lt;/pre&gt;` 匹配姓名： `&lt;pre style=&quot;background:#272822&quot;&gt;/^[\\u4e00-\\u9fa5]{2,}$/&lt;/pre&gt;` 匹配腾讯QQ号： `&lt;pre style=&quot;background:#272822&quot;&gt;/^[1-9]\\d{4,10}$/&lt;/pre&gt;` 匹配手机号： `&lt;pre style=&quot;background:#272822&quot;&gt;/^(13[0-9]|14[57]|15[0-9]|18[0-9])\\d{8}$/&lt;/pre&gt;` 匹配邮箱： `&lt;pre style=&quot;background:#272822&quot;&gt;/^\\w+([+-.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/&lt;/pre&gt;` 封装自己的trim方法 replace() 方法 格式: 字符串对象.replace(正则式或字符串，替换的目标字符) 返回值: 替换后的新字符串 封装自己的trim()方法 1234567//使用trim()方法检测用户输入function trim(str) &#123; return str.replace(/^\\s+/,\"\").replace(/\\s+$/,\"\");&#125;function trim(str) &#123; return str.replace(/^\\s+|\\s+$/g,\"\");&#125;","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"无缝轮播图","slug":"无缝轮播图","date":"2015-02-25T12:30:15.000Z","updated":"2017-02-28T12:58:27.429Z","comments":true,"path":"2015/02/25/无缝轮播图/","link":"","permalink":"http://yoursite.com/2015/02/25/无缝轮播图/","excerpt":"","text":"无缝轮播图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; padding: 0; margin: 0; list-style: none; border: 0; &#125; .all &#123; width: 500px; height: 200px; padding: 7px; border: 1px solid #ccc; margin: 100px auto; position: relative; &#125; .screen &#123; width: 500px; height: 200px; /*overflow: hidden;*/ position: relative; &#125; .screen li &#123; width: 500px; height: 200px; overflow: hidden; float: left; &#125; .screen ul &#123; position: absolute; left: 0; top: 0px; width: 3000px; &#125; .all ol &#123; position: absolute; right: 10px; bottom: 10px; line-height: 20px; text-align: center; &#125; .all ol li &#123; float: left; width: 20px; height: 20px; background: #fff; border: 1px solid #ccc; margin-left: 10px; cursor: pointer; &#125; .all ol li.current &#123; background: yellow; &#125; #arr &#123; display: none; &#125; #arr span &#123; width: 40px; height: 40px; position: absolute; left: 5px; top: 50%; margin-top: -20px; background: #000; cursor: pointer; line-height: 40px; text-align: center; font-weight: bold; font-family: '黑体'; font-size: 30px; color: #fff; opacity: 0.3; border: 1px solid #fff; &#125; #arr #right &#123; right: 5px; left: auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"all\" id='box'&gt; &lt;div class=\"screen\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"images/1.jpg\" width=\"500\" height=\"200\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/2.jpg\" width=\"500\" height=\"200\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/3.jpg\" width=\"500\" height=\"200\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/4.jpg\" width=\"500\" height=\"200\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/5.jpg\" width=\"500\" height=\"200\"/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt;&lt;/ol&gt; &lt;/div&gt; &lt;div id=\"arr\"&gt;&lt;span id=\"left\"&gt;&amp;lt;&lt;/span&gt;&lt;span id=\"right\"&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var timer = null; //0.找人 var box = document.getElementById(\"box\"); var screen = box.children[0]; var ul = screen.children[0]; var ol = screen.children[1]; var ulLis = ul.children;//所有的广告 //箭头 var arr = document.getElementById(\"arr\"); var left = document.getElementById(\"left\"); var right = document.getElementById(\"right\"); var imgWidth = screen.offsetWidth; //alert(imgWidth) //1.动态生成结构 //1.1根据广告的数量 动态生成按钮 for (var i = 0; i &lt; ulLis.length; i++) &#123; var li = document.createElement(\"li\");//循环一次就创建一个li li.innerHTML = i + 1; ol.appendChild(li);//放到ol中 &#125; //1.2给最开始的按钮先加一个高亮 var olLis = ol.children;//所有按钮 olLis[0].className = \"current\"; //1.3克隆第一张图片 放到最后 var firstImg = ulLis[0].cloneNode(true);//克隆出来的 假的第一张 ul.appendChild(firstImg); //2.鼠标经过按钮 //2.1给所有的按钮 注册鼠标经过事件 鼠标经过当前按钮 当前按钮排他 for (var j = 0; j &lt; olLis.length; j++) &#123; olLis[j].index = j;//用一个自定义属性 保存索引 olLis[j].onmouseover = function () &#123;//给每一个按钮注册鼠标经过事件 //干掉所有人 for (var k = 0; k &lt; olLis.length; k++) &#123; olLis[k].className = \"\"; &#125; //留下我自己 this.className = \"current\"; //除了要让当前按钮亮起 还要把ul移动到指定位置 //目标 和 当前按钮的索引有关 和 图片宽度有关 而且是负数 var target = -this.index * imgWidth; animate(ul, target); //*********鼠标经过按钮的时候 // 记录当前显示的图片的索引的pic 以及记录当前亮起的按钮的索引的square 要统一 //统一成当前按钮的索引 //pic = this.index; //square = this.index; pic = square = this.index; &#125;; &#125; //3.鼠标点击箭头 //3.1鼠标经过盒子显示箭头 box.onmouseover = function () &#123; arr.style.display = \"block\"; clearInterval(timer);//停止自动滚动 &#125;; //鼠标离开盒子隐藏箭头 box.onmouseout = function () &#123; arr.style.display = \"none\"; //鼠标离开后还要继续滚 timer = setInterval(right.onclick, 1000); &#125;; var pic = 0;//记录当前显示的图片的索引 var square = 0;//记录当前应该亮起的按钮 //3.2点击右箭头 right.onclick = function () &#123; //如果是最后一张图 需要把ul瞬间放到开始的位置 然后做从真的第一张到第二张的动画 if (pic === ulLis.length - 1) &#123; ul.style.left = 0 + \"px\";//瞬间放到开头 pic = 0;//把索引也归零 &#125; pic++;//计算出下一张 //目标 和pic有关 和 图片宽度有关 而且是负数 var target = -pic * imgWidth; animate(ul, target); //4.按钮也得跟着 //按钮的索引不能一直加 要判断一下 if (square &lt; olLis.length - 1) &#123;//小于最后一个按钮的索引 square++; &#125; else &#123; square = 0; &#125; //排他 //干掉所有人 for (var i = 0; i &lt; olLis.length; i++) &#123; olLis[i].className = \"\"; &#125; //留下对应的 olLis[square].className = \"current\"; &#125;; //3.3点击左箭头 left.onclick = function () &#123; //如果是第一张图 需要把ul瞬间放到最后的位置 然后做从假的第一张到真的最后一张 if (pic === 0) &#123; ul.style.left = -(ulLis.length - 1) * imgWidth + \"px\";//瞬间放到最后 pic = ulLis.length - 1;//把索引也变为最后的 &#125; pic--;//计算出下一张 //目标 和pic有关 和 图片宽度有关 而且是负数 var target = -pic * imgWidth; animate(ul, target); //4.按钮也得跟着 //按钮的索引不能一直减小 要判断一下 if (square &gt; 0) &#123;//大于第一个按钮的索引 square--; &#125; else &#123; square = olLis.length - 1;//等于最后一个按钮的索引 &#125; //排他 //干掉所有人 for (var i = 0; i &lt; olLis.length; i++) &#123; olLis[i].className = \"\"; &#125; //留下对应的 olLis[square].className = \"current\"; &#125;; timer = setInterval(right.onclick, 1000);//自动滚动 function animate(obj, target) &#123; clearInterval(obj.timer); obj.timer = setInterval(function () &#123; var leader = obj.offsetLeft; var step = 30; step = leader &lt; target ? step : -step;//往左往右都行 if (Math.abs(leader - target) &gt;= Math.abs(step)) &#123;//距离大于步长就可以走 leader = leader + step; obj.style.left = leader + \"px\"; &#125; else &#123; obj.style.left = target + \"px\";//手动放到目标上 clearInterval(obj.timer); &#125; &#125;, 15); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"DOM笔记","slug":"DOM笔记","date":"2015-02-21T08:23:49.000Z","updated":"2017-02-28T12:34:31.502Z","comments":true,"path":"2015/02/21/DOM笔记/","link":"","permalink":"http://yoursite.com/2015/02/21/DOM笔记/","excerpt":"","text":"DOM笔记内容概念 文档(Document)：就是指HTML或者XML文件； 节点(Node)：HTML文档中的所有内容都可以称之为节点，常见的节点有： 元素节点 属性节点 文本节点 注释节点 元素(Element)：HTML文档中的标签可以称为元素 获取元素getElementById();//通过id获取元素(只能被document调用) getElementsByTagName();//通过标签名获取元素，返回一个由元素对象组成的伪数组(既可以被document调用，又可以被元素对象调用，被元素对象调用时表示在该元素对象内部执行查找) getElementsByClassName();//通过类名获取元素，返回一个由元素对象组成的伪数组。IE6、7、8有兼容问题(既可以被document调用，又可以被元素对象调用，被元素对象调用时表示在该元素对象内部执行查找) 123456789101112131415161718192021222324//封装 通过类名获取元素 的兼容函数function getElementsByClassName(element,className) &#123; if(element.getElementsByClassName) &#123;//如果支持，直接返回 return element.getElementsByClassName(className); &#125; else &#123; //寻找指定元素内部所有的标签 一个一个标签去判断 //如果符合要求 就放到一个数组里 最后返回这个数组 var filterArr = []; var elements = element.getElementsByTagName(\"*\"); //把每个标签取出来一个一个判断类名是否符合要求 for(var i = 0; i &lt; elements.length; i++) &#123; var nameArr = elements[i].className.split(\" \"); //遍历类名数组 看看有没有和className相等的类名 for(var j = 0; j &lt; nameArr.length; j++) &#123; //nameArr[j]//每一个类名 if(nameArr[j] === className) &#123;//当前元素是我要的 filterArr.push(elements[i]);//把当前元素放入数组 break;//跳出对当前元素的类名的数组的循环 &#125; &#125; &#125; return filterArr; &#125;&#125; 设置属性元素对象.属性名 = &quot;属性值&quot;; 等价于： &lt;标签 属性名=&quot;属性值&quot;&gt; 绑定事件事件三要素: 事件源.事件 = function () { 事件处理程序 }; 等价于: &lt;标签 事件 = &quot;事件处理程序&quot;&gt; 内部文本属性 innerHTML; //获取和设置标签中的内容。 设置的时候，如果如果是符合标签规则的文本 会设置成标签。即设置的内容会当作节点对象被解析到DOM树上。 调用方式：element.innerHTML = &quot;content&quot;; box.innerHTML = &quot;&lt;li&gt;1&lt;/li&gt;&quot;;//直接当做li标签，页面上只显示 ·1 innerText //获取和设置标签中的内容，设置的内容不管是否是符合标签规则的文本，都会被当作普通文本。有兼容问题，用textContent代替 调用方式：element.innerText = &quot;content&quot; box.innerText = &quot;&lt;li&gt;1&lt;/li&gt;&quot;;//页面上输出&lt;li&gt;1&lt;/li&gt; 通过能力检测封装一个自己的设置内部文本的方法12345678//设置内部文本兼容性函数function setInnerText(element,content) &#123; if(typeof element.innerText === \"String\") &#123; element.innerText = content; &#125; else &#123; element.textContent = content; &#125;&#125; 12345678//获取内部文本的兼容性函数function getInnerText(element) &#123; if(typeof element.innerText === \"String\") &#123; return element.innerText; &#125; else &#123; return element.textContent; &#125;&#125; 常用表单属性 常见的表单元素属性有： type、value、checked、selected、disabled type：可以设置input元素的类型 value：可以设置input元素的值 checked：可以设置input元素是否选中 selected：可以设置下拉列表select中的option是否被选中 disabled：可以设置input元素是否被禁用 文本框获取焦点和失去焦点 获取焦点 事件是onfocus 失去焦点 事件是onblur (不是所有的标签都有这个事件) 自定义属性 w3c规定的属性 标签和对象会相互影响 没规定的各自是各自的 标签中有规定的属性 会反映到对象上 标签中没有规定的属性 不会反映到对象上 标签中有规定的属性 在对象身上修改 会影响标签 标签中没有规定的属性 在对象身上修改 不会影响标签 getAttribute();//设置标签属性 setAttribute();//获取标签属性 removeAttribute();//移除标签属性 节点(node) 节点类型 node.nodeType;//返回数字 1：表示元素节点； 2：表示属性节点； 3：表示文本节点； 8：表示注释节点； 节点名称 node.nodeName;//节点名称（标签名） 节点值 node.nodeValue;//元素节点的nodeValue始终是null 节点层次 所有获取节点相关属性都没有兼容性问题 childNodes //子节点 children //子元素 所有浏览器都支持 nextSibling //下一个兄弟节点 nextElementSibling //下一个兄弟元素 有兼容性问题 previousSibling//上一个兄弟节点 previousElementSibling //上一个兄弟元素 有兼容性问题 firstChild //第一个节点 firstElementChild //第一个子元素 有兼容性问题 lastChild //最后一个子节点 lastElementChild //最后一个子元素 有兼容性问题 parentNode //父节点 （一定是元素节点，所以无需处理） 封装函数来解决兼容性问题123456789101112131415//获取下一个兄弟元素function getNextElementSibling(element) &#123; //能力检测 if(element.nextElementSibling) &#123; return element.nextElementSibling;//如果有，直接返回 &#125; else &#123; //下一个兄弟节点 这是所有浏览器都支持的 var next = element.nextSibling; //循环条件：有下一个子节点 并且类型不是想要的 while(next &amp;&amp; next.nodeType !== 1) &#123; next = next.nextSibling; &#125; return next; &#125;&#125; 123456789101112131415//获取上一个兄弟元素function getPreviousElementSibling(element) &#123; //能力检测 if(element.previousElementSibling) &#123; return element.previousElementSibling;//如果有，直接返回 &#125; else &#123; //上一个兄弟节点 这是所有浏览器都支持的 var node = element.previousSibling; //循环条件：有上一个子节点 并且类型不是想要的 while(node &amp;&amp; node.nodeType !== 1) &#123; node = node.previousSibling; &#125; return node; &#125;&#125; 123456789101112//获取节点的第一个子元素function getFirstElement(element) &#123; if(element.firstElementChild) &#123; return element.firstElementChild; &#125; else &#123; var node = element.firstChild; while(node &amp;&amp; 1 != node.nodeType) &#123; node = node.nextSibling; &#125; return node; &#125;&#125; 123456789101112//获取节点的最后一个子元素function getLastElement(element) &#123; if(element.lastElementChild) &#123; return element.lastElementChild; &#125; else &#123; var node = element.lastChild; while(node &amp;&amp; 1 != node.nodeType) &#123; node = node.previousSibling; &#125; return node; &#125;&#125; 事件类型 onmouseover:鼠标经过 onmouseout:鼠标离开 onclick:点击 onkeyup:键盘弹起 onkeydown:键盘按下 onfocus:文本框获取焦点 onblur:文本框失去焦点 调用方式：btn.onclick = function() { 事件处理程序 }; 样式属性 style属性是对象，style对象的属性是字符串 style只能获取和设置行内样式 DOM对象中style的属性和标签中style内的值几乎一样 只是带有 - 的属性名较为特殊（如background-color变成了backgroundColor），因为在JS中 - 不能作为标识符 设置和获取样式 通过对象的style属性只能设置和获取行内样式 获取样式的时候 如果行内没有该样式 输出空字符串 设置样式的时候 赋的值是一个字符串 如果这个属性有单位 一定要记得加单位 style对象 对应的是行内样式 获取样式 只能获取行内样式 获取到的是字符串 只有属性值 会带有单位 设置样式 设置的是行内样式(注意路径问题) 设置的也是字符串 一定要记得加单位 只设置值即可 常用属性 backgroundColor backgroundImage color width height border opacity (IE8以前filter: alpha(opacity=xx))//透明度 position left top right bottom z-index//层级（设置层级时，一定要先设置定位） display//元素隐藏后，不占位置，页面上的元素会重新排列 取值：none/block visibility//元素隐藏后，占位置 取值：hidden/visible 什么情况通过class 控制样式？什么情况通过style 控制样式？ 不严格的说： 如果样式很多，通过 直接控制类名 的方式加样式 如果样式比较少，通过直接设置比较方便 严格来说： 从标准的角度讲，即使是样式比较少的时候，设置样式也要用类名 但是有一类情况，是无论如何也必须直接通过JS加的–那就是涉及到计算的时候 动态创建元素 插入和移除节点 克隆节点 克隆的节点.cloneNode(布尔值);//参数为布尔值，false表示浅度克隆，即只克隆当前节点；true表示深度克隆，即把此节点的所有子节点一起克隆 在父元素中的最后追加子元素 father.appendChild(要追加的节点对象);//如果要追加的节点对象是已经存在的，则将该已存在的节点对象从原位置删除，放到要追加的位置；如果要追加的节点对象是克隆出来的，则原节点对象在原位置不变，只把克隆出来的节点对象放到要追加的位置。 在父元素中的某个子元素前面插入子元素 father.insertBefore(要插入的节点对象,插到这个节点对象的前面);//如果要追加的节点对象是已经存在的，则将该已存在的节点对象从原位置删除，放到要追加的位置；如果要追加的节点对象是克隆出来的，则原节点对象在原位置不变，只把克隆出来的节点对象放到要追加的位置。 从父元素中移除子元素 father.removeChild(要移除的子节点对象); 清空父元素 father.innerHTML=&quot;&quot;;//在清空内容的时候和事件相关的函数不会被销毁，任然遗留在内存中 因此如果方便的话，建议使用father.removeChild(son)来清除 动态创建结构 方式一：直接在文档中书写 document.write(&quot;内容&quot;);//如果页面已经加载好了 会把所有内容都干掉。write方法无法限定范围，只能被document调用. 方式二：改变元素对象内部的HTML innerHTML = &quot;内容&quot;;//可以限定范围。如果页面已经加载好了，会把所有内容都干掉。 调用方式：element.innerHTML = &quot;content&quot;; innerText//可以限定范围,有兼容问题，用textContent代替(兼容函数见第58行) 调用方式：element.innerText = &quot;content&quot; 方式三：创建或克隆节点并追加 createElement(tagName); cloneNode(); 然后appendChild()将节点追加到后面或者insertBefore()将节点插入到指定位置 通过这两种方法创建出来的元素只是保存在内存中，必须放到页面上才行!","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]}]}